% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}



\usepackage{graphicx}

%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{Approximate construction of Hurwitz maps\mbox{}}}\\
\vfill

\hypersetup{pdftitle=Approximate construction of Hurwitz maps}
\markright{\scriptsize \mbox{}\hfill Approximate construction of Hurwitz maps \hfill\mbox{}}
\mbox{}\\[2cm]
\hypersetup{pdfauthor=}
\end{center}\vfill

\mbox{}\\
\end{titlepage}

\newpage\setcounter{page}{2}
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 1 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Package description}}\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7ECA93657DC3DCF1}{}
{
  Given a k-tuple of permutations representing the monodromy of a rational map,
the implemented algorithm constructs an arbitrarily precise floating-point
complex approximation of that map. For detailed description of the method see
our article: ...\\
\\
 The package also supports lifting of isolated smooth (polynomial) system
solution over a prime field to an extension field of rationals and computing
corresponding solution approximations over complex numbers. }

 
\chapter{\textcolor{Chapter }{ Installation (Linux) }}\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X81A76D627F8163B6}{}
{
  Since the HMAC package was created only recently, there is no packaged version
for any Linux distribution out there for now. Therefore parts of the
installation has to be done manually by the user or by a system administrator
or it is possible to use a virtual machine image (TO BE CREATED) for
nonproduction environment (due to to a considerable performance penalty).\\
\\
 For the setup by hand you have to install, if not already present 
\begin{itemize}
\item - a C++ compiler (e.g. GCC)
\item - (GNU) Make
\item - Bash shell 
\item -the GAP computer algebra system; release 4.5.6 or later from:\\
 \href{http://www.gap-system.org/Releases/index.html } {\texttt{http://www.gap-system.org/Releases/index.html }} 
\end{itemize}
 For example run in a terminal:\\
\\
 \texttt{wget
ftp://ftp.gap-system.org/pub/gap/gap4/tar.gz/gap4r5p6{\textunderscore}2012{\textunderscore}11{\textunderscore}04-18{\textunderscore}46.tar.gz}\\
 \texttt{tar -xvf
gap4r5p6{\textunderscore}2012{\textunderscore}11{\textunderscore}04-18{\textunderscore}46.tar.gz }\\
 \texttt{cd gap4r5} \texttt{./configure \# (eventually pass parameters; see './configure --help'}\\
 \texttt{make}\\
\\
 Also mandatory are the GAP packages 
\begin{itemize}
\item -'FLOAT' ( \href{https://github.com/laurentbartholdi/float.git } {\texttt{https://github.com/laurentbartholdi/float.git }} )
\item -and 'FR' ( \href{https://github.com/laurentbartholdi/fr.git } {\texttt{https://github.com/laurentbartholdi/fr.git }} )
\item - and the package 'HMAC' itself
\end{itemize}
 Please place them (not mandatory) in the subfolder \texttt{\$GAPDIR/pkg}, e.g.:\\
\\
 \texttt{cd \$GAPDIR/pkg }\\
 git checkout \href{https://github.com/laurentbartholdi/float.git } {\texttt{https://github.com/laurentbartholdi/float.git }} float\\
 git checkout \href{https://github.com/laurentbartholdi/fr.git } {\texttt{https://github.com/laurentbartholdi/fr.git }} fr\\
\\
\\
 Then change to the float directory; \\
 run \texttt{'./configure'} and \texttt{'make'}\\
 After that, build the fr package similarily.\\
\\
 If building 'FR' or 'FLOAT' fails on your system, please report the observed
issues.\\
\\
 You may also try alternatively FLOAT and FR from \\
 \href{ https://github.com/jakobkroeker/float.git} {\texttt{ https://github.com/jakobkroeker/float.git}}\\
 \href{ https://github.com/jakobkroeker/fr.git} {\texttt{ https://github.com/jakobkroeker/fr.git}} \\
\\
 The HMAC package is built by running\\
 \texttt{ {\nobreakspace}{\nobreakspace} ./configure }\\
 and \\
 \texttt{ {\nobreakspace}{\nobreakspace} make }\\
 \\
 If the build processs fails due to a missing package, please install them on
your system and retry. See also \texttt{'./configure --help'} for options on that. \\
 For further support contact the package developers directly. }

 
\chapter{\textcolor{Chapter }{Quickstart}}\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X7F83DF528480AEA3}{}
{
  For the impatiend users who just want to compute some maps or to lift a smooth
isolated point over a prime field to an extension field of rationals, here are
a couple of small examples:\\
\\
 - Example as in article ..( page 3). \\
 Expected result: 3z{\textsuperscript2} {\ensuremath{-}} 2z{\textsuperscript3} \\
 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  gap>
  !gapprompt|gap>B !gapinput|finiteField := GF(5);;permutations := [(1,2,3),(2,3),(1,2)];;B
  !gapprompt|gap>B !gapinput|complexCriticalValuesApprox := [ [infinity,infinity],  [0,0], [ 1/1, 0 ] ];;B
  !gapprompt|gap>B !gapinput|modPCriticalValues := [ infinity, Zero(finiteField),  One(finiteField) ];;B
  !gapprompt|gap>B !gapinput|hmsProblem := Hurwitz@HMAC.HurwitzMapSearchProblem( B
  !gapprompt|>B !gapinput|permutations , complexCriticalValuesApprox );;B
  !gapprompt|gap>B !gapinput|	B
  !gapprompt|gap>B !gapinput|############# finite field searchB
  !gapprompt|gap>B !gapinput|mapsModPrime := Hurwitz@HMAC.FindHurwitzMapModPrime( B
  !gapprompt|>B !gapinput|finiteField , permutations, modPCriticalValues );;B
  !gapprompt|gap>B !gapinput|Size(mapsModPrime); # we have a hitB
  1
  !gapprompt|gap>B !gapinput|############# lift and approximate Hurwitz map candidatesB
  !gapprompt|gap>B !gapinput|mapModPrime :=    mapsModPrime[1];;B
  !gapprompt|gap>B !gapinput|polynomialTuple := mapModPrime[2];; # the W_i'sB
  !gapprompt|gap>B !gapinput|mapCandidates := Hurwitz@HMAC.ApproxComplexHurwitzMaps( B
  !gapprompt|>B !gapinput|    hmsProblem, polynomialTuple, finiteField, @HMAC@PadicLift.LiftOptions() );;B
  !gapprompt|gap>B !gapinput|mapCandidates[1].map;B
  (-2._z)*z^3+3._z*z^2 
  !gapprompt|gap>B !gapinput|mapCandidates[1].maxResidue; ## approximation errorB
  0.
   
\end{Verbatim}
 ComputeApproxIdealPoints: 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing( Rationals  ,["x","y"] );B
  !gapprompt|gap>B !gapinput|indeterminates := IndeterminatesOfPolynomialRing(rng);B
  !gapprompt|gap>B !gapinput|x := indeterminates[1];B
  !gapprompt|gap>B !gapinput|y := indeterminates[2];B
  !gapprompt|gap>B !gapinput|FZ1 := 33*x^3+19*x^2-81*x-4;B
  !gapprompt|gap>B !gapinput|FZ2 := y-1;B
  !gapprompt|gap>B !gapinput|ideal := Ideal(rng,[FZ1,FZ2]);B
  !gapprompt|gap>B !gapinput|pointOverPrimeField := [ Z(11)^0, Z(11)^0 ];  B
  !gapprompt|gap>B !gapinput|options := LiftOptions@HMAC();B
  !gapprompt|gap>B !gapinput|result := ComputeApproxIdealPoints@HMAC( ideal, pointOverPrimeField, options);B
\end{Verbatim}
 Compute minimal polynomials for the unknowns from a prime field solution: 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing( Rationals  ,["x","y"] );B
  !gapprompt|gap>B !gapinput|indeterminates := IndeterminatesOfPolynomialRing(rng);B
  !gapprompt|gap>B !gapinput|x := indeterminates[1];B
  !gapprompt|gap>B !gapinput|y := indeterminates[2];B
  !gapprompt|gap>B !gapinput|FZ1 := 33*x^3+19*x^2-81*x-4;B
  !gapprompt|gap>B !gapinput|FZ2 := y-1;B
  !gapprompt|gap>B !gapinput|ideal := Ideal(rng,[FZ1,FZ2]);B
  !gapprompt|gap>B !gapinput|solutionOverFiniteField := [ Z(11)^0, Z(11)^0 ];  B
  !gapprompt|gap>B !gapinput|options := LiftOptions@HMAC();B
  !gapprompt|gap>B !gapinput|unknown := indeterminates[1];B
  !gapprompt|gap>B !gapinput|liftedSolutionData := ComputeMinimalPolynomial@HMAC B
  !gapprompt|>B !gapinput|( ideal, solutionOverFiniteField, unknown, options );B
   
\end{Verbatim}
 P-adic lift: 
\begin{Verbatim}[commandchars=|BD,fontsize=\small,frame=single,label=Example]
  |gappromptBgap>D |gapinputB rng := PolynomialRing( Rationals  ,["x","y"] );;D
  |gappromptBgap>D |gapinputBindeterminates := IndeterminatesOfPolynomialRing(rng);;D
  |gappromptBgap>D |gapinputBx := indeterminates[1];; y := indeterminates[2];;D
  |gappromptBgap>D |gapinputBFZ1 := 33*x^3+19*x^2-81*x-4;D
  |gappromptBgap>D |gapinputBFZ2 := y-1;D
  |gappromptBgap>D |gapinputBideal := Ideal(rng,[FZ1,FZ2]);D
  |gappromptBgap>D |gapinputBsolutionOverFiniteField := [ One(Z(11)), One(Z(11)) ];;D
  |gappromptBgap>D |gapinputBlift := PadicLift@HMAC( ideal, solutionOverFiniteField, 2 );D
  [ ZmodnZObj( 4148, 14641 ), ZmodnZObj( 1, 14641 ) ]
  |gappromptBgap>D |gapinputB#check:D
  |gappromptBgap>D |gapinputB@HMAC@Utils.EvalPolynomialTensorD
  |gappromptB>D |gapinputB( GeneratorsOfTwoSidedIdeal(ideal), indeterminates, lift );D
  [ ZmodnZObj( 0, 14641 ), ZmodnZObj( 0, 14641 ) ] #ok!
\end{Verbatim}
 }

 
\chapter{\textcolor{Chapter }{Package organisation}}\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X7FA0374D7CAD2194}{}
{
  The package functions are separated into three (pseudo-)namespaces: 
\begin{description}
\item[{\texttt{@HMAC@Utils:}}]  list and polynomial manipulation utils 
\item[{\texttt{@HMAC@PadicLift:}}]  functions for lifting an isolated smooth solution over a finite field to an
extension field of rationals and also compute approximations over complex
numbers 
\item[{\texttt{@HMAC@Hurwitz:}}]  arbitrarily precise floating-point complex approximation of a Hurwitz ration
map. 
\end{description}
 The namespaces are simulated by using a GAP record object. Private functions
are placed in a subrecord 'Internal'. With this setup it is easy to list all
API functions of a specific purpose, e.g. by typing \\
 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|@HMAC@PadicLift.B
\end{Verbatim}
 \\
 into the console and using auto-completition (TAB key). All functions also
present at the global function space, e.g. \texttt{@HMAC@Utils.ConstantTerm} is also callable by \texttt{ConstantTerm@HMAC...} }

 
\chapter{\textcolor{Chapter }{ List manipulation utils }}\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X798C2AFE78D28FA5}{}
{
  The purpose of provided util functions is to extend the core GAP functionality
for list manipulation.\\
\\
 The namespace prefix \textsc{"@HMAC@Utils."} or postfix \textsc{"@HMAC..."} is usually omitted, except in the example code. 
\section{\textcolor{Chapter }{ Flatten a list; first and last elements }}\logpage{[ 5, 1, 0 ]}
\hyperdef{L}{X80B79A257D011631}{}
{
  

\subsection{\textcolor{Chapter }{FlattenList}}
\logpage{[ 5, 1, 1 ]}\nobreak
\hyperdef{L}{X7AE80D4C7D69AE69}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FlattenList({\mdseries\slshape list})\index{FlattenList@\texttt{FlattenList}}
\label{FlattenList}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a flattened list



 Removes the top level nesting of \mbox{\texttt{\mdseries\slshape list}}; 

Example: }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|list:=[1,[2,1]];B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.FlattenList( list );B
   [1,2,1]
  !gapprompt|gap>B !gapinput|@HMAC@Utils.FlattenList( [1,[2,[1]]]  );B
   [1,2,[1]]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{FirstElement}}
\logpage{[ 5, 1, 2 ]}\nobreak
\hyperdef{L}{X872317D185008F1C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FirstElement({\mdseries\slshape list})\index{FirstElement@\texttt{FirstElement}}
\label{FirstElement}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
first list element or \texttt{fail}



 get the first \mbox{\texttt{\mdseries\slshape list}} element; If the list is empty, the operation fails. 

Example: }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|list:=[1,[2,1]];B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.FirstElement( list );B
  1
  !gapprompt|gap>B !gapinput|@HMAC@Utils.FirstElement( [ ]  );B
   fail
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LastElement}}
\logpage{[ 5, 1, 3 ]}\nobreak
\hyperdef{L}{X7E45B68B81C05440}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LastElement({\mdseries\slshape list})\index{LastElement@\texttt{LastElement}}
\label{LastElement}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
last list element or \texttt{fail}



 get the last \mbox{\texttt{\mdseries\slshape list}} element; If the list is empty, the operation fails. 

Example: }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|list:=[1,[2,1]];B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.LastElement( list );B
  [2,1]
  !gapprompt|gap>B !gapinput|@HMAC@Utils.LastElement( [ ]  );B
   fail
\end{Verbatim}
 }

 }

 
\chapter{\textcolor{Chapter }{ Polynomial manipulation utils }}\logpage{[ 6, 0, 0 ]}
\hyperdef{L}{X8083360D7B566704}{}
{
  The purpose of provided util functions is to extend the core GAP functionality
for polynomial manipulation. Performant implementation was not a goal, since
it could require a complete redesign and a rewrite of existing structure and
functions in the core of GAP. For users who need performant operations we
refer to external C++ libraries like FLINT. \\
\\
 Following functions extend the core functionality to manipulate polynomials.\\
 The namespace prefix \textsc{"@HMAC@Utils."} or postfix \textsc{"@HMAC..."} is usually omitted, except in the example code. 
\section{\textcolor{Chapter }{ Properties }}\logpage{[ 6, 1, 0 ]}
\hyperdef{L}{X871597447BB998A1}{}
{
  \index{degree!polynomial } 

\subsection{\textcolor{Chapter }{Degree}}
\logpage{[ 6, 1, 1 ]}\nobreak
\hyperdef{L}{X826A861E7E7D944E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Degree({\mdseries\slshape multivariatePolynomial})\index{Degree@\texttt{Degree}}
\label{Degree}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
Degree of the polynomial



 Degree of the zero polynomial is set to \texttt{-infinity}; 

Example: }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|polynomialRing := PolynomialRing(GF(13), ["t","s"]);;B
  !gapprompt|gap>B !gapinput|t :=IndeterminatesOfPolynomialRing(polynomialRing)[1];;B
  !gapprompt|gap>B !gapinput|s :=IndeterminatesOfPolynomialRing(polynomialRing)[2];;B
  !gapprompt|gap>B !gapinput|polynomial := s^2+4+t^3*s^4;;B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.Degree(polynomial);B
  7
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsMonomial}}
\logpage{[ 6, 1, 2 ]}\nobreak
\hyperdef{L}{X858E852687C80F21}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsMonomial({\mdseries\slshape polynomial})\index{IsMonomial@\texttt{IsMonomial}}
\label{IsMonomial}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{true/false} 



 Checks if the passed parameter is a monomial; 

Example: }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|polynomialRing := PolynomialRing( Rationals, ["t","s"]);;B
  !gapprompt|gap>B !gapinput|t :=IndeterminatesOfPolynomialRing(polynomialRing)[1];;B
  !gapprompt|gap>B !gapinput|s :=IndeterminatesOfPolynomialRing(polynomialRing)[2];;B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.IsMonomial(s^2);B
  true
  !gapprompt|gap>B !gapinput|@HMAC@Utils.IsMonomial(2*s^2);B
  false
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{CoefficientOfPolynomial}}
\logpage{[ 6, 1, 3 ]}\nobreak
\hyperdef{L}{X7CE0691D819563C1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CoefficientOfPolynomial({\mdseries\slshape polynomial, monomial})\index{CoefficientOfPolynomial@\texttt{CoefficientOfPolynomial}}
\label{CoefficientOfPolynomial}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 the monomial coefficient of the polynomial 



 

Example: }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|polynomialRing := PolynomialRing( Rationals, ["t","s"]);;B
  !gapprompt|gap>B !gapinput|t :=IndeterminatesOfPolynomialRing(polynomialRing)[1];;B
  !gapprompt|gap>B !gapinput|s :=IndeterminatesOfPolynomialRing(polynomialRing)[2];;B
  !gapprompt|gap>B !gapinput|s :=IndeterminatesOfPolynomialRing(polynomialRing)[2];;B
  !gapprompt|gap>B !gapinput|polynomial:= 3*s^2+t;;B
  !gapprompt|gap>B !gapinput|monomial:= s^2;;B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.CoefficientOfPolynomial( polynomial , monomial );B
  3
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Coefficients}}
\logpage{[ 6, 1, 4 ]}\nobreak
\hyperdef{L}{X80B32F667BF6AFD8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Coefficients({\mdseries\slshape polynomial{\nobreakspace}[, monomialList{\nobreakspace}]})\index{Coefficients@\texttt{Coefficients}}
\label{Coefficients}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 the coefficient list corresponding to to the passed monomialList or all
coefficients if second parameter was omitted



 

Example: }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|polynomialRing := PolynomialRing( Rationals, ["t","s"]);;B
  !gapprompt|gap>B !gapinput|t :=IndeterminatesOfPolynomialRing(polynomialRing)[1];;B
  !gapprompt|gap>B !gapinput|s :=IndeterminatesOfPolynomialRing(polynomialRing)[2];;B
  !gapprompt|gap>B !gapinput|monomialList := [s^2,t];;B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.Coefficients( 4*s^2+t , monomialList );B
  [ 4, 1 ]
  !gapprompt|gap>B !gapinput|@HMAC@Utils.Coefficients( 4*s^2+t+3 );B
  [ 3, 1, 4 ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{CoefficientsEx}}
\logpage{[ 6, 1, 5 ]}\nobreak
\hyperdef{L}{X7A6B5EA17B50FA4C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CoefficientsEx({\mdseries\slshape polynomial{\nobreakspace}[, monomialList{\nobreakspace}]})\index{CoefficientsEx@\texttt{CoefficientsEx}}
\label{CoefficientsEx}
}\hfill{\scriptsize (function)}}\\


 \textbf{\indent Returns:\ }
 the coefficient list and corresponding monomialList 



 

Example: }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|polynomialRing := PolynomialRing( Rationals, ["t","s"]);;B
  !gapprompt|gap>B !gapinput|t :=IndeterminatesOfPolynomialRing(polynomialRing)[1];;B
  !gapprompt|gap>B !gapinput|s :=IndeterminatesOfPolynomialRing(polynomialRing)[2];;B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.CoefficientsEx(4*s^2+t);B
  [ [ 1, 4 ], [ t, s^2 ] ]
  !gapprompt|gap>B !gapinput|@HMAC@Utils.CoefficientsEx(4*s^2+t , [ s^2, t^2, t ]);B
  [ [ 4, 0, 1 ], [ s^2, t^2, t ] ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{MonomialCoefficient}}
\logpage{[ 6, 1, 6 ]}\nobreak
\hyperdef{L}{X83E3E57B7A4F7CA6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MonomialCoefficient({\mdseries\slshape polynomial, monomial})\index{MonomialCoefficient@\texttt{MonomialCoefficient}}
\label{MonomialCoefficient}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 the monomial coefficient of the polynomial 



 

Example: }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|polynomialRing := PolynomialRing( Rationals, ["t","s"]);;B
  !gapprompt|gap>B !gapinput|t :=IndeterminatesOfPolynomialRing(polynomialRing)[1];;B
  !gapprompt|gap>B !gapinput|s :=IndeterminatesOfPolynomialRing(polynomialRing)[2];;B
  !gapprompt|gap>B !gapinput|polynomial := 4*s^2+t;;B
  !gapprompt|gap>B !gapinput|monomial := s^2;;B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.MonomialCoefficient( polynomial , monomial );B
  4
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{CountPolynomialVariables}}
\logpage{[ 6, 1, 7 ]}\nobreak
\hyperdef{L}{X81E5348387DA5D57}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CountPolynomialVariables({\mdseries\slshape polynomial})\index{CountPolynomialVariables@\texttt{CountPolynomialVariables}}
\label{CountPolynomialVariables}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 number of variables appeared in a polynomial. 



 Count variables appeared in a polynomial. Zero monomials are ignored.\\
 See also the \textsf{GAP} core function \texttt{OccuringVariableIndices} }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@rng := PolynomialRing(Rationals,["x","y"]);;|
  !gapprompt@gap>| !gapinput@ind:=IndeterminatesOfPolynomialRing(rng);;|
  !gapprompt@gap>| !gapinput@x := ind[1];;|
  !gapprompt@gap>| !gapinput@pol := 5/3*x+y;;|
  !gapprompt@gap>| !gapinput@CountPolynomialVariables(pol);|
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{ConstantTerm}}
\logpage{[ 6, 1, 8 ]}\nobreak
\hyperdef{L}{X874BF7787EA25EF1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConstantTerm({\mdseries\slshape polynomial})\index{ConstantTerm@\texttt{ConstantTerm}}
\label{ConstantTerm}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 the constant term 



 

Example: }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|polynomialRing := PolynomialRing( Rationals, ["t"]);;B
  !gapprompt|gap>B !gapinput|t :=IndeterminatesOfPolynomialRing(polynomialRing)[1];;B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.ConstantTerm(3*t^2+t+7 );B
  7
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsIndeterminate}}
\logpage{[ 6, 1, 9 ]}\nobreak
\hyperdef{L}{X786E71F58687243D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsIndeterminate({\mdseries\slshape object})\index{IsIndeterminate@\texttt{IsIndeterminate}}
\label{IsIndeterminate}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 \texttt{true} or \texttt{false} 



 Check if the passed object is an indeterminate of a polynomial ring\\
 }

 

\subsection{\textcolor{Chapter }{IndeterminatesOfPolynomial}}
\logpage{[ 6, 1, 10 ]}\nobreak
\hyperdef{L}{X86FFC6697CAF53B8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IndeterminatesOfPolynomial({\mdseries\slshape polynomial})\index{IndeterminatesOfPolynomial@\texttt{IndeterminatesOfPolynomial}}
\label{IndeterminatesOfPolynomial}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a list of \mbox{\texttt{\mdseries\slshape polynomial}} indeterminates 



 Check if the passed object is an indeterminate of a polynomial ring\\
 }

 }

 
\section{\textcolor{Chapter }{ Derivative }}\logpage{[ 6, 2, 0 ]}
\hyperdef{L}{X7B57CEE2780D0E0B}{}
{
  

\subsection{\textcolor{Chapter }{Jacobian}}
\logpage{[ 6, 2, 1 ]}\nobreak
\hyperdef{L}{X8435668286687181}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Jacobian({\mdseries\slshape polynomialList{\nobreakspace}[, indeterminantList{\nobreakspace}]})\index{Jacobian@\texttt{Jacobian}}
\label{Jacobian}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 compute ( $\frac{d[ polynomial_i] }{d[indeterminants_j] }$) 



 

Example: }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing(Rationals,["x","y"]);B
  !gapprompt|gap>B !gapinput|ind := IndeterminatesOfPolynomialRing(rng);B
  !gapprompt|gap>B !gapinput|x := ind[1]; y := ind[2];B
  !gapprompt|gap>B !gapinput|pol := 5/3*x;B
  !gapprompt|gap>B !gapinput|jacobian := @HMAC@Utils.Jacobian( [pol,y^2], [x,y] );B
  [ [ 5/3, 0 ], [ 0, 2*y ] ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{ Coercion }}\logpage{[ 6, 3, 0 ]}
\hyperdef{L}{X86430F2984A792C2}{}
{
  

\subsection{\textcolor{Chapter }{CoerceScalar}}
\logpage{[ 6, 3, 1 ]}\nobreak
\hyperdef{L}{X7F06C0E883430579}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CoerceScalar({\mdseries\slshape scalar, destRing})\index{CoerceScalar@\texttt{CoerceScalar}}
\label{CoerceScalar}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 coerced scalar 



 Try to coerce a scalar to a specific ring. \\
 \\
 Does not handle all cases. 

Example: }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|@HMAC@Utils.CoerceScalar( 1/3,  GF(11) );B
  Z(11)^2
  !gapprompt|gap>B !gapinput|@HMAC@Utils.CoerceScalar( 1/3,  ZmodnZ(11) ); B
  Z(11)^2
  !gapprompt|gap>B !gapinput|@HMAC@Utils.CoerceScalar( Z(11)^2, Integers ); B
  4
  !gapprompt|gap>B !gapinput|@HMAC@Utils.CoerceScalar( 1/3, Integers );B
  # fails with an error
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{CoercePolynomial}}
\logpage{[ 6, 3, 2 ]}\nobreak
\hyperdef{L}{X7D8821A185A568B1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CoercePolynomial({\mdseries\slshape scalar, destRing})\index{CoercePolynomial@\texttt{CoercePolynomial}}
\label{CoercePolynomial}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 coerced polynomial 



 Try to coerce a polynomial to a specific ring. \\
 \\
 Has problems with iterative polynomial destination rings. 

Example: }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing(Rationals,["x"]);;B
  !gapprompt|gap>B !gapinput|ind:=IndeterminatesOfPolynomialRing(rng);;B
  !gapprompt|gap>B !gapinput|x := ind[1];;B
  !gapprompt|gap>B !gapinput|pol := 5/3*x;;B
  !gapprompt|gap>B !gapinput|dstRng := PolynomialRing( ZmodnZ(11) ,["x'"]);;B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.CoercePolynomial(pol, dstRng);B
  Z(11)^6*x'
  !gapprompt|gap>B !gapinput|dstRng := PolynomialRing(ZmodnZ(121) ,["x''"]);;B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.CoercePolynomial(pol, dstRng);B
  ZmodnZObj(42,121)*x''
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{CoerceTensor}}
\logpage{[ 6, 3, 3 ]}\nobreak
\hyperdef{L}{X7B3B312086C925E2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CoerceTensor({\mdseries\slshape tensor})\index{CoerceTensor@\texttt{CoerceTensor}}
\label{CoerceTensor}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 coerced tensor 



 Try to coerce a value, a list or a multidimensional array to a specific ring. \\
 \\
 Has problems with iterative polynomial destination rings. 

Example: }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing(Rationals,["x"]);;B
  !gapprompt|gap>B !gapinput|ind:=IndeterminatesOfPolynomialRing(rng);;B
  !gapprompt|gap>B !gapinput|x := ind[1];;B
  !gapprompt|gap>B !gapinput|dstRng := PolynomialRing( ZmodnZ(11) ,["x'"]);;B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.CoerceTensor([5/3*x,x], dstRng);B
  [ ZmodnZObj(42,121)*x'', x'' ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{ Evaluation }}\logpage{[ 6, 4, 0 ]}
\hyperdef{L}{X7E5B9E0F800A509A}{}
{
  

\subsection{\textcolor{Chapter }{EvalPolynomialTensor}}
\logpage{[ 6, 4, 1 ]}\nobreak
\hyperdef{L}{X7E14E9827B53D855}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{EvalPolynomialTensor({\mdseries\slshape tensor, indeterminates, values})\index{EvalPolynomialTensor@\texttt{EvalPolynomialTensor}}
\label{EvalPolynomialTensor}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 evaluated polynomial tensor 



 substitute all \mbox{\texttt{\mdseries\slshape indeterminates}} in the \mbox{\texttt{\mdseries\slshape tensor}} by corresponding \mbox{\texttt{\mdseries\slshape values}}. \\
 Precondition: \mbox{\texttt{\mdseries\slshape tensor}} elements are polynomials over \mbox{\texttt{\mdseries\slshape indeterminates}} and indeterminates belong to the same ring.\\
 Postconditon: \mbox{\texttt{\mdseries\slshape indeterminates[i]}} in \mbox{\texttt{\mdseries\slshape tensor}} are replaced by \mbox{\texttt{\mdseries\slshape values[i]}}; 

Example: }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing(Rationals,["x","y"]);;B
  !gapprompt|gap>B !gapinput|ind:=IndeterminatesOfPolynomialRing(rng);;B
  !gapprompt|gap>B !gapinput|x := ind[1];; y:=ind[2];;B
  !gapprompt|gap>B !gapinput|mat:=[[1/3*x^0, x^0,x+y]];B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.EvalPolynomialTensorB
  >(mat, [x,y],[ZmodnZObj( 1, 121 ),ZmodnZObj( 2, 121 )]);
  [ [ ZmodnZObj( 81, 121 ), ZmodnZObj( 1, 121 ), ZmodnZObj( 3, 121 ) ] ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{ Factorisation }}\logpage{[ 6, 5, 0 ]}
\hyperdef{L}{X8127DC517AE2B0B4}{}
{
  

\subsection{\textcolor{Chapter }{DistinctMonicFactors}}
\logpage{[ 6, 5, 1 ]}\nobreak
\hyperdef{L}{X7998936D82ED77E2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DistinctMonicFactors({\mdseries\slshape univariatePolynomial})\index{DistinctMonicFactors@\texttt{DistinctMonicFactors}}
\label{DistinctMonicFactors}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a list of distinct irreducible monic factors or \texttt{fail} if polynomial was zero 



 Returns distinct irreducible monic factors of an univariate polynomial or of a
homogenized univariate polynomial\\
 }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing( ZmodnZ(11)  ,["x","y" ] );;B
  !gapprompt|gap>B !gapinput|indeterminates := IndeterminatesOfPolynomialRing(rng);;B
  !gapprompt|gap>B !gapinput|x := indeterminates[1];;  y := indeterminates[2];;B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.DistinctMonicFactors(  x^3+5*x+4  );B
  [ x+Z(11)^6, x+Z(11)^7, x+Z(11)^9 ]
  !gapprompt|gap>B !gapinput|@HMAC@Utils.DistinctMonicFactorsB
  !gapprompt|>B !gapinput|(  x^3+5*x*y^2+4*y^3  ); # homogenized univariate polynomialB
  [ x+Z(11)^6*y, x+Z(11)^7*y, x+Z(11)^9*y ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{FactorsInPowerForm}}
\logpage{[ 6, 5, 2 ]}\nobreak
\hyperdef{L}{X7B448954859CC5E1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FactorsInPowerForm({\mdseries\slshape polynomial})\index{FactorsInPowerForm@\texttt{FactorsInPowerForm}}
\label{FactorsInPowerForm}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a list of pairs of [base,exponent] ) with distinct bases where a base is a
monic irreducible factor or a constant



 factors an univariate polynomial over rationals or finite fields into power
factors\\
 See also the \textsf{GAP} core function \texttt{Factors}. }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing( ZmodnZ(11)  ,["x","y" ] );;B
  !gapprompt|gap>B !gapinput|indeterminates := IndeterminatesOfPolynomialRing(rng);;B
  !gapprompt|gap>B !gapinput|x := indeterminates[1];;  y := indeterminates[2];;B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.FactorsInPowerForm(2*(x-3)^3*x^2);B
  [ [ Z(11), 1 ], [ x, 2 ], [ x+Z(11)^3, 3 ] ]
  !gapprompt|gap>B !gapinput|Factors(2*(x-3)^3*x^2);B
  [ Z(11)*x, x, x+Z(11)^3, x+Z(11)^3, x+Z(11)^3 ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LinearFactors}}
\logpage{[ 6, 5, 3 ]}\nobreak
\hyperdef{L}{X7BF6555E7B663FB5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LinearFactors({\mdseries\slshape polynomial{\nobreakspace}[, wantedLinearFactorMultiplicity]})\index{LinearFactors@\texttt{LinearFactors}}
\label{LinearFactors}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a list of distinct linear factors either with given or with arbitrary
multiplicity



 get distinct linear factors with arbitraray or given multiplicity\\
 }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing( ZmodnZ(11)  ,["x","y" ] );;B
  !gapprompt|gap>B !gapinput|indeterminates := IndeterminatesOfPolynomialRing(rng);;B
  !gapprompt|gap>B !gapinput|x := indeterminates[1];;  y := indeterminates[2];;B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.LinearFactors( (x^2+x+1)*2*(x-3)^3*x^2, 2);B
  [ x ]
  !gapprompt|gap>B !gapinput|@HMAC@Utils.LinearFactors( (x^2+x+1)*2*(x-3)^3*x^2 );B
  [ x, x+Z(11)^3 ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{ Root computation }}\logpage{[ 6, 6, 0 ]}
\hyperdef{L}{X8195168C7AE42D4A}{}
{
  

\subsection{\textcolor{Chapter }{DecimalToBitPrecision}}
\logpage{[ 6, 6, 1 ]}\nobreak
\hyperdef{L}{X799E5C027DEC08B5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DecimalToBitPrecision({\mdseries\slshape decimalPrecision})\index{DecimalToBitPrecision@\texttt{DecimalToBitPrecision}}
\label{DecimalToBitPrecision}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 corresponding bit precision 



 Converts decimal to bit precision \\
 Caution: some exact binary representations cannot be converted to decimal
representation and vize versa. }

 
\begin{Verbatim}[commandchars=!|E,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>E !gapinput|DecimalToBitPrecision@HMAC(3);E
  10
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{RootsByJenkinsTraub}}
\logpage{[ 6, 6, 2 ]}\nobreak
\hyperdef{L}{X83AAD025797AD51B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RootsByJenkinsTraub({\mdseries\slshape univariatePolynomial, decimalPrecision})\index{RootsByJenkinsTraub@\texttt{RootsByJenkinsTraub}}
\label{RootsByJenkinsTraub}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a list of polynomial roots 



 Computes univariate polynomial roots using a method by Jenkins and Traub \\
 }

 
\begin{Verbatim}[commandchars=!|D,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>D !gapinput|rng := PolynomialRing( Rationals  ,[ "x" ] );;D
  !gapprompt|gap>D !gapinput|indeterminates := IndeterminatesOfPolynomialRing(rng);;D
  !gapprompt|gap>D !gapinput|x := indeterminates[1];; D
  !gapprompt|gap>D !gapinput|RootsByJenkinsTraub@HMAC( (x^2+1), 15 );D
  [ .0e0+.1.i, -.0e0-.1.i ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{CreateJenkinsTraubWrapper}}
\logpage{[ 6, 6, 3 ]}\nobreak
\hyperdef{L}{X8502CE247C8130E7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CreateJenkinsTraubWrapper({\mdseries\slshape decimalPrecision})\index{CreateJenkinsTraubWrapper@\texttt{CreateJenkinsTraubWrapper}}
\label{CreateJenkinsTraubWrapper}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 an object with an interface to compute roots, see detailed description: 



 The created object interface is:\\
 - \texttt{computeRoots(univariatePolynomial)} -method, returns a list of roots. \\
 - \texttt{coercePolynomial(polynomial) } computes the coerced complex polynomial which is finally passed to the root
calculator.\\
 \\
and a couple of properties:\\
 - \texttt{getDecimalPrecision() } returns the decimal precision of the root calculator\\
 - \texttt{getBitPrecision() } returns the bit precision of the root calculator\\
 - \texttt{getPolynomialRing() } returns the complex polynomial ring to which the input polynomial will be
coerced before root computation\\
 - \texttt{getDstPolynomialFam() }\\
 \\
 The obvious purpose of this interface design is to allow transparent usage of
different root finding algorithms. }

 \\
 Example: 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing( Rationals  ,[ "x" ] );;B
  !gapprompt|gap>B !gapinput|indeterminates := IndeterminatesOfPolynomialRing(rng);;B
  !gapprompt|gap>B !gapinput|x := indeterminates[1];;B
  !gapprompt|gap>B !gapinput|decimalPrecision := 15;;B
  !gapprompt|gap>B !gapinput|rootCalculator := CreateJenkinsTraubWrapper@HMAC ( decimalPrecision );B
  !gapprompt|gap>B !gapinput|rootCalculator.computeRoots( (x^2+1) );B
  [ 0.+1.i, -0.-1.i ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{ Miscellaneous }}\logpage{[ 6, 7, 0 ]}
\hyperdef{L}{X7C5563A37D566DA5}{}
{
  

\subsection{\textcolor{Chapter }{IsPower}}
\logpage{[ 6, 7, 1 ]}\nobreak
\hyperdef{L}{X855D17417C415EB0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPower({\mdseries\slshape object})\index{IsPower@\texttt{IsPower}}
\label{IsPower}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 \texttt{true} or \texttt{false}



 Check if data structure is a pair [a,b] where a\texttt{\symbol{94}}b is a
supported operation\\
 }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing( ZmodnZ(11)  ,["x","y" ] );;B
  !gapprompt|gap>B !gapinput|indeterminates := IndeterminatesOfPolynomialRing(rng);;B
  !gapprompt|gap>B !gapinput|x := indeterminates[1];;  y := indeterminates[2];;B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.IsPower([   Z(11), 1 ] );B
  true
  !gapprompt|gap>B !gapinput|@HMAC@Utils.IsPower([   Z(11), x ] );B
  false
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{CreatePower}}
\logpage{[ 6, 7, 2 ]}\nobreak
\hyperdef{L}{X7A121BF080D1660C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CreatePower({\mdseries\slshape base, exponent})\index{CreatePower@\texttt{CreatePower}}
\label{CreatePower}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a pair [\mbox{\texttt{\mdseries\slshape base}},\mbox{\texttt{\mdseries\slshape exponent}}], if \mbox{\texttt{\mdseries\slshape base\texttt{\symbol{94}}exponent}} is appliable 



 Creates a power [\mbox{\texttt{\mdseries\slshape base}},\mbox{\texttt{\mdseries\slshape exponent}}] if possible\\
 }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing( ZmodnZ(11)  ,["x","y" ] );;B
  !gapprompt|gap>B !gapinput|indeterminates := IndeterminatesOfPolynomialRing(rng);;B
  !gapprompt|gap>B !gapinput|x := indeterminates[1];;  y := indeterminates[2];;B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.CreatePower(   Z(11), 1  );B
  [ Z(11), 1 ]
  !gapprompt|gap>B !gapinput|@HMAC@Utils.CreatePower(   Z(11), x );B
  # fails
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{ProductValue}}
\logpage{[ 6, 7, 3 ]}\nobreak
\hyperdef{L}{X7E70C643799ADC40}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ProductValue({\mdseries\slshape powerList})\index{ProductValue@\texttt{ProductValue}}
\label{ProductValue}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 product of \mbox{\texttt{\mdseries\slshape powerList}} elements ).



 computes the value of a product (a product is currently a list of powers. A
power is a pair [ base, exponent ] ).\\
 }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing( ZmodnZ(11)  ,["x","y" ] );;B
  !gapprompt|gap>B !gapinput|indeterminates := IndeterminatesOfPolynomialRing(rng);;B
  !gapprompt|gap>B !gapinput|x := indeterminates[1];;  y := indeterminates[2];;B
  !gapprompt|gap>B !gapinput|@HMAC@Utils.ProductValue([ [ Z(11), 1 ], [ x, 2 ], [ x+Z(11)^3, 3 ] ] );B
  Z(11)*x^5+Z(11)^2*x^4-x^3+x^2
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{HomogenizedPolynomial}}
\logpage{[ 6, 7, 4 ]}\nobreak
\hyperdef{L}{X7AA456AF83470850}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HomogenizedPolynomial({\mdseries\slshape polynomial, homogenVar[, finalDegree]})\index{HomogenizedPolynomial@\texttt{HomogenizedPolynomial}}
\label{HomogenizedPolynomial}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 \texttt{true} or \texttt{false} 



 Homogenize an polynomial using homogenVar as homogeneous variable\\
 If possible, the returned polynomial will be homogeneous [ with given degree
]. }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing( ZmodnZ(11) ,["x" ] );;B
  !gapprompt|gap>B !gapinput|indeterminates := IndeterminatesOfPolynomialRing(rng);;B
  !gapprompt|gap>B !gapinput|x := indeterminates[1];; B
  !gapprompt|gap>B !gapinput|rng2 := PolynomialRing( ZmodnZ(11) ,[ "x" ] );;B
  !gapprompt|gap>B !gapinput|indeterminates := IndeterminatesOfPolynomialRing(rng);;B
  !gapprompt|gap>B !gapinput|y := indeterminates[1];; B
  !gapprompt|gap>B !gapinput|pol:= x+2;; B
  !gapprompt|gap>B !gapinput|hpol:= @HMAC@Utils.HomogenizedPolynomial(pol,y);B
  x+2*y
  !gapprompt|gap>B !gapinput|hpol:= @HMAC@Utils.HomogenizedPolynomial(pol, y, 2 );B
  x*y+2*y^2
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsHomogenized}}
\logpage{[ 6, 7, 5 ]}\nobreak
\hyperdef{L}{X841C00C9808DBB1A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsHomogenized({\mdseries\slshape polynomial})\index{IsHomogenized@\texttt{IsHomogenized}}
\label{IsHomogenized}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 \texttt{true} or \texttt{false} 



 Check if the passed polynomial is homogeneous\\
 }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing( ZmodnZ(11) ,["x","y" ] );;B
  !gapprompt|gap>B !gapinput|indeterminates := IndeterminatesOfPolynomialRing(rng);;B
  !gapprompt|gap>B !gapinput|x := indeterminates[1];; y := indeterminates[2];; B
  !gapprompt|gap>B !gapinput|pol:= x^2+2;; B
  !gapprompt|gap>B !gapinput|hpol:= "@HMAC@Utils.IsHomogenized(pol);B
  false
  !gapprompt|gap>B !gapinput|hpol:= "@HMAC@Utils.IsHomogenized( x^2+2*y^2 );B
  true
\end{Verbatim}
 }

 }

 
\chapter{\textcolor{Chapter }{ P-adic lift }}\logpage{[ 7, 0, 0 ]}
\hyperdef{L}{X7E52699D800AF8EB}{}
{
  If an algebraic problem has a solution over the extension field of rational
numbers that reduces to a smooth isolated point over a prime field, where the
latter is found by smart brute force search, the point can be lifted back
using Hensel lifting and lattice basis reduction. This result is the basis for
the implemented lifting algorithm. 
\section{\textcolor{Chapter }{ P-adic lift functions }}\logpage{[ 7, 1, 0 ]}
\hyperdef{L}{X7B9AB7308349BEFA}{}
{
  

\subsection{\textcolor{Chapter }{PadicLift}}
\logpage{[ 7, 1, 1 ]}\nobreak
\hyperdef{L}{X7FA4B2047EB52B99}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PadicLift({\mdseries\slshape ideal, solutionPoint, numLiftDepth})\index{PadicLift@\texttt{PadicLift}}
\label{PadicLift}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a $solution \pmod (char\;\; solutionPoint)^{ (2^{numLiftDepth}) }$ 



 For an \mbox{\texttt{\mdseries\slshape ideal}} in a polynomial ring over rationals and a \mbox{\texttt{\mdseries\slshape solutionPoint}} over a prime field $\mathbb F_p$ computes an improved p-adic approximation mod
p\texttt{\symbol{94}}(2\texttt{\symbol{94}}\mbox{\texttt{\mdseries\slshape numLiftDepth}}) \\
 }

 Example: 
\begin{Verbatim}[commandchars=|BD,fontsize=\small,frame=single,label=Example]
  |gappromptBgap>D |gapinputB rng := PolynomialRing( Rationals  ,["x","y"] );;D
  |gappromptBgap>D |gapinputBindeterminates := IndeterminatesOfPolynomialRing(rng);;D
  |gappromptBgap>D |gapinputBx := indeterminates[1];; y := indeterminates[2];;D
  |gappromptBgap>D |gapinputBFZ1 := 33*x^3+19*x^2-81*x-4;D
  |gappromptBgap>D |gapinputBFZ2 := y-1;D
  |gappromptBgap>D |gapinputBideal := Ideal(rng,[FZ1,FZ2]);D
  |gappromptBgap>D |gapinputBsolutionOverFiniteField := [ One(Z(11)), One(Z(11)) ];;D
  |gappromptBgap>D |gapinputBlift := PadicLift@HMAC( ideal, solutionOverFiniteField, 2 );D
  [ ZmodnZObj( 4148, 14641 ), ZmodnZObj( 1, 14641 ) ]
  |gappromptBgap>D |gapinputB#check:D
  |gappromptBgap>D |gapinputB@HMAC@Utils.EvalPolynomialTensorD
  |gappromptB>D |gapinputB( GeneratorsOfTwoSidedIdeal(ideal), indeterminates, lift );D
  [ ZmodnZObj( 0, 14641 ), ZmodnZObj( 0, 14641 ) ] #ok!
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{QuadraticLiftStep}}
\logpage{[ 7, 1, 2 ]}\nobreak
\hyperdef{L}{X7B62284B7C245A8D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{QuadraticLiftStep({\mdseries\slshape idealGens, jacobian, indeterminates, idealPointPadicApprox})\index{QuadraticLiftStep@\texttt{QuadraticLiftStep}}
\label{QuadraticLiftStep}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a higher p-adic approximation of \mbox{\texttt{\mdseries\slshape idealPointPadicApprox}} 



 Computes next p-adic approximation: \\
 If the idealPointPadicApprox is a p-adic approximation $\pmod k$, the next one will be $\pmod k^2$. }

 Example: 
\begin{Verbatim}[commandchars=|BD,fontsize=\small,frame=single,label=Example]
  |gappromptBgap>D |gapinputB rng := PolynomialRing( Rationals  ,["x","y"] );;D
  |gappromptBgap>D |gapinputBindeterminates := IndeterminatesOfPolynomialRing(rng);;D
  |gappromptBgap>D |gapinputBx := indeterminates[1];; y := indeterminates[2];;D
  |gappromptBgap>D |gapinputBFZ1 := 33*x^3+19*x^2-81*x-4;D
  |gappromptBgap>D |gapinputBFZ2 := y-1;D
  |gappromptBgap>D |gapinputBideal := Ideal(rng,[FZ1,FZ2]);D
  |gappromptBgap>D |gapinputBsolutionApprox := [ One(Z(11)), One(Z(11)) ];;D
  |gappromptBgap>D |gapinputBgens := GeneratorsOfTwoSidedIdeal(ideal);;D
  |gappromptBgap>D |gapinputBjacobian :=  @HMAC@Utils.Jacobian( gens, indeterminates );;D
  |gappromptBgap>D |gapinputBnextApprox := QuadraticLiftStep@HMACD
  |gappromptB>D |gapinputB( gens, jacobian, indeterminates, solutionApprox );D
  [ ZmodnZObj( 34, 121 ), ZmodnZObj( 1, 121 ) ]
  |gappromptBgap>D |gapinputBnextApprox := QuadraticLiftStep@HMACD
  |gappromptB>D |gapinputB( gens, jacobian, indeterminates, nextApprox );D
  [ ZmodnZObj( 4148, 14641 ), ZmodnZObj( 1, 14641 ) ]
  |gappromptBgap>D |gapinputB#check:D
  |gappromptBgap>D |gapinputB@HMAC@Utils.EvalPolynomialTensor( gens, indeterminates, nextApprox );D
  [ ZmodnZObj( 0, 14641 ), ZmodnZObj( 0, 14641 ) ] #ok!
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LiftOptions}}
\logpage{[ 7, 1, 3 ]}\nobreak
\hyperdef{L}{X780AE8BC80963734}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LiftOptions({\mdseries\slshape })\index{LiftOptions@\texttt{LiftOptions}}
\label{LiftOptions}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a set of p-adic lift options 



 Creates an record of p-adic lift options.\\
 \texttt{.Getters()}: Display all get-functions\\
 \texttt{.Setters()}: Display all set-functions:\\
 \texttt{.print()}: Print all lift options:\\
 }

 Example: see \texttt{ComputeMinimalPolynomials} 

\subsection{\textcolor{Chapter }{ComputeMinimalPolynomial}}
\logpage{[ 7, 1, 4 ]}\nobreak
\hyperdef{L}{X7ED970C67A52BA35}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ComputeMinimalPolynomial({\mdseries\slshape ideal, finiteFieldSolution, unknown, liftOptions})\index{ComputeMinimalPolynomial@\texttt{ComputeMinimalPolynomial}}
\label{ComputeMinimalPolynomial}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a GAP record with computation statistics and the minimal polynomial if the
computation succeeded \\




 For an ideal over rationals and a ideal point 'solution', a given unknown
(linear combination of indetermilates of the ideal ring is allowed) try to
compute the minimal polynomial for the unknown using p-adic lift followed by
lattice reduction. For mathematical details see the article ...\\
\\
 The outer iteration of the algorithm increases the p-adic precision of passed
ideal point 'solution' and the inner iteration tries to compute a minimal
polynomial for the unknown by applying the lattice basis redution method to
the p-adic approximation see also \texttt{LatticeBasisReductionStep}(\ref{LatticeBasisReductionStep}) and \texttt{LiftOptions}(\ref{LiftOptions})\\
 The used variable symbol in the returned minimal polynomial is the unknown, if
unknown is an indeterminate of the polynomial ring, otherwise just an
arbitraty indetermitate of the polynomial ring }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing( Rationals  ,["x","y"] );B
  !gapprompt|gap>B !gapinput|indeterminates := IndeterminatesOfPolynomialRing(rng);B
  !gapprompt|gap>B !gapinput|x := indeterminates[1];B
  !gapprompt|gap>B !gapinput|y := indeterminates[2];B
  !gapprompt|gap>B !gapinput|FZ1 := 33*x^3+19*x^2-81*x-4;B
  !gapprompt|gap>B !gapinput|FZ2 := y-1;B
  !gapprompt|gap>B !gapinput|ideal := Ideal(rng,[FZ1,FZ2]);B
  !gapprompt|gap>B !gapinput|solutionOverFiniteField := [ Z(11)^0, Z(11)^0 ];  B
  !gapprompt|gap>B !gapinput|options := LiftOptions@HMAC();B
  !gapprompt|gap>B !gapinput|unknown := indeterminates[1];B
  !gapprompt|gap>B !gapinput|liftedSolutionData := ComputeMinimalPolynomial@HMAC B
  !gapprompt|>B !gapinput|( ideal, solutionOverFiniteField, unknown, options );B
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{ComputeMinimalPolynomials}}
\logpage{[ 7, 1, 5 ]}\nobreak
\hyperdef{L}{X864863FC79FDC0BB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ComputeMinimalPolynomials({\mdseries\slshape ideal, finiteFieldSolution, unknowns, computeOptions})\index{ComputeMinimalPolynomials@\texttt{ComputeMinimalPolynomials}}
\label{ComputeMinimalPolynomials}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a record of statistics and minimal polynomials for the unknowns , if the
computation succeeded \\




 Given an ideal ( in a polynomial ring over rationals) and a ideal point over a
prime field, try to find the corresponding minimal polynomials for all
unknowns, where each unknown may be a linear combination of the ideal ring
indeterminates.\\
 Requirements: the solution over the prime field is smooth and isolated.\\
 See also: \texttt{ComputeMinimalPolynomial}(\ref{ComputeMinimalPolynomial}) }

 

\subsection{\textcolor{Chapter }{ComputeApproxIdealPoints}}
\logpage{[ 7, 1, 6 ]}\nobreak
\hyperdef{L}{X85F361EC8092B9C5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ComputeApproxIdealPoints({\mdseries\slshape inputIdeal, solutionPoint, opts})\index{ComputeApproxIdealPoints@\texttt{ComputeApproxIdealPoints}}
\label{ComputeApproxIdealPoints}
}\hfill{\scriptsize (function)}}\\


 For an input ideal over rationals and a ideal point over a prime field, lift
the given point to an extension field of rationals and return complex
approximations of the lifted point results together with residue values and
computation statistics: \\
 The function returns a GAP record with fields\\
 \texttt{approxIdealElems:} a list of approximate ideal elements\\
 \texttt{residue: } max error \\
 \texttt{mergedLiftInfo:} statistics about lifting \\
 \texttt{minPolyData:} minimal polynomial data for the indeterminates of the ideal ring\\
 See also \texttt{ComputeMinimalPolynomials}(\ref{ComputeMinimalPolynomials}) and the corresponding article at: }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing( Rationals  ,["x","y"] );B
  !gapprompt|gap>B !gapinput|indeterminates := IndeterminatesOfPolynomialRing(rng);B
  !gapprompt|gap>B !gapinput|x := indeterminates[1];B
  !gapprompt|gap>B !gapinput|y := indeterminates[2];B
  !gapprompt|gap>B !gapinput|FZ1 := 33*x^3+19*x^2-81*x-4;B
  !gapprompt|gap>B !gapinput|FZ2 := y-1;B
  !gapprompt|gap>B !gapinput|ideal := Ideal(rng,[FZ1,FZ2]);B
  !gapprompt|gap>B !gapinput|pointOverPrimeField := [ Z(11)^0, Z(11)^0 ];  B
  !gapprompt|gap>B !gapinput|options := LiftOptions@HMAC();B
  !gapprompt|gap>B !gapinput|result := ComputeApproxIdealPoints@HMAC( ideal, pointOverPrimeField, options);B
  
\end{Verbatim}
 }

 }

 
\chapter{\textcolor{Chapter }{ Approximate Hurwitz map construction }}\logpage{[ 8, 0, 0 ]}
\hyperdef{L}{X87062A887BC47828}{}
{
  
\section{\textcolor{Chapter }{ Polynomial shape computation }}\logpage{[ 8, 1, 0 ]}
\hyperdef{L}{X7BA0FB457C976F65}{}
{
  

\subsection{\textcolor{Chapter }{Shape}}
\logpage{[ 8, 1, 1 ]}\nobreak
\hyperdef{L}{X86740CE286B82FE7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Shape({\mdseries\slshape integerPartition})\index{Shape@\texttt{Shape}}
\label{Shape}
}\hfill{\scriptsize (function)}}\\


 Creates a representation for multiplicity structure of a polynomial \\
 \\
 }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|shape :=  Shape@HMAC( [4,3,2,2,2] ) ;;B
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsShape}}
\logpage{[ 8, 1, 2 ]}\nobreak
\hyperdef{L}{X8236B8A6845463EA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsShape({\mdseries\slshape object})\index{IsShape@\texttt{IsShape}}
\label{IsShape}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true or false 



 Checks if an object is a polynomial multiplicity structure representation \\
 \\
 }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|shape :=  Shape@HMAC( [4,3,2,2,2] ) ;;B
  !gapprompt|gap>B !gapinput|IsShape(shape);;B
  true
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{ComputeShape}}
\logpage{[ 8, 1, 3 ]}\nobreak
\hyperdef{L}{X7A685C5278110C7F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ComputeShape({\mdseries\slshape polynomial, expectedDegree})\index{ComputeShape@\texttt{ComputeShape}}
\label{ComputeShape}
}\hfill{\scriptsize (function)}}\\


 Computes the shape of an univariate polynomial (over rationals, integers or
galois fields). The parameter \texttt{expectedDegree} is required to determine the shape correctly if the polynomial has an infinity
root factor. \\
 \\
 }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing(Rationals, ["x"] );;B
  !gapprompt|gap>B !gapinput|ind :=IndeterminatesOfPolynomialRing(rng);;B
  !gapprompt|gap>B !gapinput|x := ind[1];;B
  !gapprompt|gap>B !gapinput|pol := 3*(x+1)*(x+2)^2;;B
  !gapprompt|gap>B !gapinput|shape := ComputeShape@HMAC( pol );;B
  !gapprompt|gap>B !gapinput|shape.partition;B
  [ 2, 1 ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{RootMultiplicity}}
\logpage{[ 8, 1, 4 ]}\nobreak
\hyperdef{L}{X81398709835FDAA8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RootMultiplicity({\mdseries\slshape polynomial, root, expectedPolDegree})\index{RootMultiplicity@\texttt{RootMultiplicity}}
\label{RootMultiplicity}
}\hfill{\scriptsize (function)}}\\


 Get the multiplicity of an univariate \texttt{ polynomial} \texttt{ root}, whereat the coefficient ring is a prime field.\\
 \texttt{expectedPolDegree} is passed to get the correct multiplicity of the infinity root.\#\# \\
 \\
 }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|rng := PolynomialRing(Rationals, ["x"] );;B
  !gapprompt|gap>B !gapinput|ind :=IndeterminatesOfPolynomialRing(rng);;B
  !gapprompt|gap>B !gapinput|x := ind[1];;B
  !gapprompt|gap>B !gapinput|pol := 3*(x+1)*(x+2)^2;;B
  !gapprompt|gap>B !gapinput|RootMultiplicity@HMAC( pol, -2 )B
  2
  !gapprompt|gap>B !gapinput|expectedPolDegree := 4;B
  !gapprompt|gap>B !gapinput|RootMultiplicity@HMAC( pol, infinity, expectedPolDegree )B
  1
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{ Hurwitz map model prime field search }}\logpage{[ 8, 2, 0 ]}
\hyperdef{L}{X7DDB81048513535A}{}
{
  

\subsection{\textcolor{Chapter }{FindHurwitzMapModPrime}}
\logpage{[ 8, 2, 1 ]}\nobreak
\hyperdef{L}{X7C43FCCB8443427C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FindHurwitzMapModPrime({\mdseries\slshape primeField, permutations, criticalValues})\index{FindHurwitzMapModPrime@\texttt{FindHurwitzMapModPrime}}
\label{FindHurwitzMapModPrime}
}\hfill{\scriptsize (function)}}\\


 Search Hurwitz map description reduced to primeField\\
 Parameters: 
\begin{itemize}
\item \texttt{primeField} search prime field
\item \texttt{permutations} represent the map monodromy
\item \texttt{criticalValues} (distinct!) of the map reduced to primeField 
\end{itemize}
 Returns a list of [ $ {W_2}/{W_1}$ , $[ W_i ] $]-pairs; \\
 where $W_2/W_1$ is a rational map of degree \texttt{d} over a prime field and the multiplicity structure for the polynomial data [
W{\textunderscore}i ] is determined by the \texttt{permutations} parameter, namely: \\
 \texttt{partitions := List(perms, p-{\textgreater}CycleLengths( p,[1..degree]) );} \\
 see \texttt{partitions} parameter description in FindHurwitzMapModPrimeEx(\ref{FindHurwitzMapModPrimeEx}); \\
 }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|finiteField := GF(5);;  permutations := [(1,2,3),(2,3),(1,2)];;B
  !gapprompt|gap>B !gapinput|modPCriticalValues := [ infinity, Zero(finiteField),  One(finiteField) ];;B
  !gapprompt|gap>B !gapinput|HurwitzMapsModPrimeData := Hurwitz@HMAC.FindHurwitzMapModPrimeB
  >( finiteField , permutations, modPCriticalValues );;
  !gapprompt|gap>B !gapinput|HurwitzMapsModPrimeData[1][1];B
  Z(5)^3*x_1^3+Z(5)^3*x_1^2
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{FindHurwitzMapModPrimeEx}}
\logpage{[ 8, 2, 2 ]}\nobreak
\hyperdef{L}{X8661925782BD3662}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FindHurwitzMapModPrimeEx({\mdseries\slshape primeField, partitions, criticalValues, bStrictNormalization})\index{FindHurwitzMapModPrimeEx@\texttt{FindHurwitzMapModPrimeEx}}
\label{FindHurwitzMapModPrimeEx}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a list of [ $ {W_2}/{W_1}$ , $[ W_i ] $]-pairs; \\
 where $W_2/W_1$ is a rational map of degree \texttt{d} over a prime field satisfying the conditions below;\\
 The multiplicity structure for the $W_i$ is determined by the \texttt{partitions[i]} parameter; \\
 where i is in [ 1 .. \#criticalValues ]\\
 At least following statements holds:\\
 {\ensuremath{\bullet}} $W_2-W_1 = W_3; $\\
 {\ensuremath{\bullet}} $W_2 - criticalValues[i]*W_1 = W_i $ for $i>3$ \\
 {\ensuremath{\bullet}} ${\ensuremath{\forall}} i,l$ with $i{\ensuremath{\neq}}l, gcd(W_i,W_l)=const;$ $ W_{i}={\ensuremath{\prod}} W_{i,j}$ with irreducible $W_{i,j}$ ;\\
 and ${\ensuremath{\forall}} j,k$ with $j{\ensuremath{\neq}}k, gcd(W_{i,j},W_{i,k})=const$ \\




 Search Hurwitz map description reduced to \texttt{primeField}\\
\\
 Parameters: 
\begin{itemize}
\item \texttt{primeField} search prime field
\item \texttt{partitions} required multiplicities of the preimages of the critical values ; 
\item \texttt{criticalValues} of the map ( reduced to primeField and distinct!)
\item \texttt{bStrictNormalization (default: false)}: \\
 if \texttt{false}, the algorithm decides, which factors of which $W_i$ will be normalized to have as root \texttt{infinity, 0 or 1 };\\
 otherwise \texttt{partitions[i][1]}determines the factor of $W_i$ by multiplicity which is normalized to \texttt{(t-criticalValues[i])} for i in 1..3 .
\end{itemize}
 Preconditions: obviously for each critical value the sum of its preimage
multiplicities is equal to map degree \texttt{d} and the implications of Riemann-Hurwitz formula holds. }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|finiteField := GF(13);;B
  !gapprompt|gap>B !gapinput|partitions := [ [2,1], [2,1], [2,1], [2,1] ];;B
  !gapprompt|gap>B !gapinput|reducedCriticalValues := [ infinity, 0, One(finiteField), Z(13)^3 ];;B
  !gapprompt|gap>B !gapinput|strictNormalization := true;;B
  !gapprompt|gap>B !gapinput|HurwitzMapsModPrimeData := Hurwitz@HMAC.FindHurwitzMapModPrimeB
  >( finiteField  ,partitions, reducedCriticalValues, strictNormalization );;
  !gapprompt|gap>B !gapinput|HurwitzMapsModPrimeData[1][1];B
  >(Z(13)^9*x_1^3+Z(13)*x_1^2)/(Z(13)^5*x_1+Z(13)^0)
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{HurwitzMapSearchSpaceSize}}
\logpage{[ 8, 2, 3 ]}\nobreak
\hyperdef{L}{X833F3334795616FB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HurwitzMapSearchSpaceSize({\mdseries\slshape primeField, permsOrShapes, criticalValues[, bIgnoreHurwitzFormula]})\index{HurwitzMapSearchSpaceSize@\texttt{HurwitzMapSearchSpaceSize}}
\label{HurwitzMapSearchSpaceSize}
}\hfill{\scriptsize (function)}}\\


 Compute search space size of Hurwitz map description reduced to primeField\\
 A useful a-priori check in the case the problem is hard!\\
\\
 Parameters: 
\begin{itemize}
\item \texttt{primeField} search prime field
\item \texttt{permutations or partitions}:\\
 permutations defining map monodromy or \\
 partitions: required multiplicities of the preimages of the critical values 
\item \texttt{(distinct!)criticalValues}: of the target map reduced to primeField 
\item \texttt{bIgnoreHurwitzFormula}: do not test if Hurwitz formula implications are satisfied by second
parameter (monodromy or partition) 
\end{itemize}
 Returns search space size of Hurwitz map description reduced to primeField.\\
\\
 See FindHurwitzMapModPrime(\ref{FindHurwitzMapModPrime}) for problem details. \\
 }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|finiteField := GF(11);; B
  !gapprompt|gap>B !gapinput|partitions := [[4,3,2,2,2], [4,3,2,2,2], [4,3,2,2,2]];;B
  !gapprompt|gap>B !gapinput|modPCriticalValues := [ infinity, Zero(finiteField),  One(finiteField) ];;B
  !gapprompt|gap>B !gapinput| Hurwitz@HMAC.HurwitzMapSearchSpaceSizeB
  >( finiteField , partitions, modPCriticalValues );
  112258800
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{NormalizationRule}}
\logpage{[ 8, 2, 4 ]}\nobreak
\hyperdef{L}{X839235607E0E56A5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NormalizationRule({\mdseries\slshape polynomialId, multiplicity, rootValue})\index{NormalizationRule@\texttt{NormalizationRule}}
\label{NormalizationRule}
}\hfill{\scriptsize (function)}}\\


 Create a normalization rule which describes what linear factor of polynomials $W_i$ (as declared in FindHurwitzMapModPrimeEx(\ref{FindHurwitzMapModPrimeEx}) should be normalized and to what form \\
\\
 Parameters: 
\begin{itemize}
\item \texttt{polynomialId}: target polynomial id i; usual 1,2, 3 or Null@HMAC( =program decides) 
\item \texttt{multiplicity} of the factor which has to be normalized. If set to Null@HMAC, the program
decides
\item \texttt{rootValue} the normalized factor will have. Can be an element of the search prime field, \\
 usually 0 or 1 or \texttt{infinity} .
\end{itemize}
 }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|finiteField := GF(11);; B
  !gapprompt|gap>B !gapinput|NormalizationRule@HMAC( 1, 4, Zero(finiteField) );;B
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{ Map approximation from prime field model }}\logpage{[ 8, 3, 0 ]}
\hyperdef{L}{X86545EE78061AD45}{}
{
  

\subsection{\textcolor{Chapter }{HurwitzMapSearchProblem}}
\logpage{[ 8, 3, 1 ]}\nobreak
\hyperdef{L}{X84EB364384BADDE0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HurwitzMapSearchProblem({\mdseries\slshape shapes, criticalValues, normalizationRules})\index{HurwitzMapSearchProblem@\texttt{HurwitzMapSearchProblem}}
\label{HurwitzMapSearchProblem}
}\hfill{\scriptsize (function)}}\\


 Create data describing a HurwitzMapSearch \\
 Parameters: 
\begin{itemize}
\item \texttt{shapes} shapes[i] is a list of multiplicities $\alpha_{i,l}$ of the preimages of the critical value $Q_i$ . (shapes of the polynomials $W_i$) 
\item \texttt{criticalValues} Expect the first three critival values normalized to infinity, zero, one and
the following as rational number approximations ( pairs of rational real and
imaginary parts )
\item \texttt{normalizationRules} see NormalizationRules 
\end{itemize}
 }

 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  !gapprompt|gap>B !gapinput|finiteField := GF(11);;  permutations := [(1,2,3),(2,3),(1,2)];;B
  !gapprompt|gap>B !gapinput|modPCriticalValues := [ infinity, Zero(finiteField),  One(finiteField) ];;B
  !gapprompt|gap>B !gapinput|mapsModPrime := Hurwitz@HMAC.FindHurwitzMapModPrimeB
  !gapprompt|>B !gapinput|( finiteField , permutations, modPrimeCriticalValues );;B
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{ApproxComplexHurwitzMaps}}
\logpage{[ 8, 3, 2 ]}\nobreak
\hyperdef{L}{X7D4B37BB837B4268}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ApproxComplexHurwitzMaps({\mdseries\slshape hmsProblem, polynomialTuple, finiteField, computeOptions})\index{ApproxComplexHurwitzMaps@\texttt{ApproxComplexHurwitzMaps}}
\label{ApproxComplexHurwitzMaps}
}\hfill{\scriptsize (function)}}\\


 Compute complex approximation of a rational map described by its critical
values and the monodromy from a prime field model \\
 \\
 Parameters: 
\begin{itemize}
\item \texttt{ hmsProblem }: the rational map search problem description; \\
 see HurwitzMapSearchProblem(\ref{HurwitzMapSearchProblem} ) 
\item \texttt{ polynomialTuple } the W{\textunderscore}i' s over a prime field; \\
 see return value of FindHurwitzMapModPrimeEx(\ref{FindHurwitzMapModPrimeEx} ) 
\item \texttt{finiteField} in case the \texttt{polynomialTuple} are given as integers, they will be coerced to prime field elements. The
coerced \texttt{ polynomialTuple} must match the problem definition \texttt{hmsProblem} (is checked)! 
\item \texttt{ computeOptions } lift and approximation options; see LiftOptions(\ref{LiftOptions}) 
\end{itemize}
 }

 Simple example as in article ..( page 3). Expected result:
3z{\textsuperscript2} {\ensuremath{-}} 2z{\textsuperscript3} \\
 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  gap>
  !gapprompt|gap>B !gapinput|finiteField := GF(5);;permutations := [(1,2,3),(2,3),(1,2)];;B
  !gapprompt|gap>B !gapinput|complexCriticalValuesApprox := [ [infinity,infinity],  [0,0], [ 1/1, 0 ] ];;B
  !gapprompt|gap>B !gapinput|modPCriticalValues := [ infinity, Zero(finiteField),  One(finiteField) ];;B
  !gapprompt|gap>B !gapinput|hmsProblem := Hurwitz@HMAC.HurwitzMapSearchProblem( B
  !gapprompt|>B !gapinput|permutations , complexCriticalValuesApprox );;B
  !gapprompt|gap>B !gapinput|	B
  !gapprompt|gap>B !gapinput|############# finite field searchB
  !gapprompt|gap>B !gapinput|mapsModPrime := Hurwitz@HMAC.FindHurwitzMapModPrime( B
  !gapprompt|>B !gapinput|finiteField , permutations, modPCriticalValues );;B
  !gapprompt|gap>B !gapinput|Size(mapsModPrime); # we have a hitB
  1
  !gapprompt|gap>B !gapinput|############# lift and approximate Hurwitz map candidatesB
  !gapprompt|gap>B !gapinput|mapModPrime :=    mapsModPrime[1];;B
  !gapprompt|gap>B !gapinput|polynomialTuple := mapModPrime[2];; # the W_i'sB
  !gapprompt|gap>B !gapinput|mapCandidates := Hurwitz@HMAC.ApproxComplexHurwitzMaps( B
  !gapprompt|>B !gapinput|    hmsProblem, polynomialTuple, finiteField, @HMAC@PadicLift.LiftOptions() );;B
  !gapprompt|gap>B !gapinput|mapCandidates[1].map;B
  (-2._z)*z^3+3._z*z^2 
  !gapprompt|gap>B !gapinput|mapCandidates[1].maxResidue; ## approximation errorB
  0.
\end{Verbatim}
 }

 }

 
\chapter{\textcolor{Chapter }{ Sandbox }}\logpage{[ 9, 0, 0 ]}
\hyperdef{L}{X7D067DAE82DD10F0}{}
{
  
\section{\textcolor{Chapter }{ Sandbox }}\logpage{[ 9, 1, 0 ]}
\hyperdef{L}{X7D067DAE82DD10F0}{}
{
  
\subsection{\textcolor{Chapter }{ subsandbox }}\logpage{[ 9, 1, 1 ]}
\hyperdef{L}{X85B121C27A152E40}{}
{
Subsection  }

 
\[(v){a_x} = w \quad\textrm{if}\quad (xv)a = x^{\pi_a}w.\]
 \texttt{ blabla; } 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@1+1;|
  4
\end{Verbatim}
 {\textless}A{\textgreater}:\mbox{\texttt{\mdseries\slshape vec2}}\\
 {\textless}B{\textgreater}:\textsc{vec2}\\
 {\textless}C{\textgreater}:\texttt{vec2}\\
 {\textless}F{\textgreater}:\texttt{vec2}\\
 {\textless}K{\textgreater}:\texttt{vec2}\\
 {\textless}E{\textgreater}:\emph{ vec2}\\
 {\textless}Math{\textgreater}:$bla$ \\
 {\textless}Emph{\textgreater}:\emph{vec2} \\
 {\textless}Q{\textgreater}:``vec2''\\
 
\begin{description}
\item[{\texttt{name}}]  a string or a list of strings, the latter meaning several preferences which
belong together, 
\end{description}
 \textsf{GAP} 

\subsection{\textcolor{Chapter }{SetGAPDocTextTheme}}
\logpage{[ 9, 1, 2 ]}\nobreak
\hyperdef{L}{X7DEB37417BBD8941}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SetGAPDocTextTheme({\mdseries\slshape [optrec]})\index{SetGAPDocTextTheme@\texttt{SetGAPDocTextTheme}}
\label{SetGAPDocTextTheme}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AsPermutation({\mdseries\slshape o})\index{AsPermutation@\texttt{AsPermutation}!FR object}
\label{AsPermutation:FR object}
}\hfill{\scriptsize (method)}}\\


 This method takes as argument an FR object \mbox{\texttt{\mdseries\slshape o}}: machine, element, or group, and produces an equivalent object whose outputs
are permutations. In particular, it converts Mealy machines from domain
representation to int representation. 

 If this is not possible, the method returns \texttt{fail}. }

 }

 {\textless}Alt Only="HTML"{\textgreater}:  \\
 {\textless}end Alt Only="HTML"{\textgreater}:\\
 {\textless}Table{\textgreater}: \begin{center}
\begin{tabular}{r|cccccccccc}$n$&
1&
2&
3&
4&
5&
6&
7&
8&
9&
10\\
\end{tabular}\\[2mm]
\textbf{Table: }Table\end{center}

 {\textless}Package{\textgreater}:\textsf{HMAC} }

 \def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
