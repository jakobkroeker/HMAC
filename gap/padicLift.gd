#############################################################################
##
#W p-adicLift                                                  Jakob Kr√∂ker
##                                                               
##
#H   @(#)$Id$
##
#Y Copyright (C) 2012, Laurent Bartholdi
##
#############################################################################
##
##
##
##############################################################################


# Dependencies: hurwitz/utils.g, package 'Float'
#
# todo: replace some more of the 'Asserts' with error messages
#
# open questions:
# how to get a list of all defined variable in a package XY?



######################################################## PUBLIC #############################################################
#BindGlobal("@HMAC@PadicLift" , rec() ) ;
#DeclareGlobalFunction( "@HMAC@PadicLift.");

BindGlobal("@HMAC@PadicLift" , rec() ) ;
DeclareGlobalFunction( "@HMAC@PadicLift.");
@HMAC@PadicLift.Tests    := rec();
@HMAC@PadicLift.Internal := rec();


######### p-adic lift

# lift a solution point mod prime to module prime^(2^numLiftDepth) (p-adic approximation)
#Parameters: ( ideal,  solutionPoint , numLiftDepth)
DeclareGlobalFunction( "PadicLift@HMAC" );
@HMAC@PadicLift.PadicLift := PadicLift@HMAC;
DeclareGlobalFunction( "@HMAC@PadicLift.PadicLift" );


# given an ideal and its jacobian over integers/rationals, compute next padic approximation mod p^2k for for an solution mod p^k.
# Parameters: ( ideal generators, jacobian, indeterminates, solutionApprox )
DeclareGlobalFunction( "QuadraticLiftStep@HMAC" );
@HMAC@PadicLift.QuadraticLiftStep := QuadraticLiftStep@HMAC;
DeclareGlobalFunction( "@HMAC@PadicLift.QuadraticLiftStep" );

# given an function to test if a point belongs to an ideal and a function which computes a jacobian for a given ideal point,
# lifts a solution point mod prime to module prime^(2^numLiftDepth) (p-adic approximation)
#Parameters: ( evaluateIdealGens, jacobianAt,  solutionPoint , numLiftDepth)
DeclareGlobalFunction( "BlackBoxPadicLift@HMAC" );
@HMAC@PadicLift.BlackBoxPadicLift := BlackBoxPadicLift@HMAC;
DeclareGlobalFunction( "@HMAC@PadicLift.BlackBoxPadicLift" );


# given an function to test if a point belongs to an ideal and a function which computes a jacobian for a given ideal point,
# computes next padic approximation mod p^2k for for an solution mod p^k.
# Parameters:  ( evalIdealGens, computeJacobianAt, solutionApprox )
DeclareGlobalFunction( "BlackBoxQuadraticLiftStep@HMAC" );    
@HMAC@PadicLift.BlackBoxQuadraticLiftStep := BlackBoxQuadraticLiftStep@HMAC;
DeclareGlobalFunction( "@HMAC@PadicLift.BlackBoxQuadraticLiftStep" );


######### compute minimal polynomials and approximate ideal points from given solution over a finite field.

# given a finite field point of an ideal compute corresponding approximate ideal points over complex numbers.
#
# Parameters:   ideal (  generated by polynomials over integers or rationals), 
#               ideal point over finite field , 
#               computation options (LiftOptions) 
#
# See also 'LiftOptions()'.
DeclareGlobalFunction( "ComputeApproxIdealPoints@HMAC" );
@HMAC@PadicLift.ComputeApproxIdealPoints := ComputeApproxIdealPoints@HMAC;
DeclareGlobalFunction( "@HMAC@PadicLift.ComputeApproxIdealPoints" ); # hack: to show function names when using tab completition for PadicLift 


# given a finite field point of an ideal and an unknown compute corresponding minimal polynomial for the unknown over integers.
# Parameters:  ( ideal, solution, unknown,  liftOptions )
DeclareGlobalFunction( "ComputeMinimalPolynomial@HMAC" );
@HMAC@PadicLift.ComputeMinimalPolynomial := ComputeMinimalPolynomial@HMAC;
DeclareGlobalFunction( "@HMAC@PadicLift.ComputeMinimalPolynomial" );


# Parameters:  ( ideal, solution, unknown, minimalPolynomialVariable, liftOptions )
# minimalPolynomialVariable: usually same as unknown. See also CreateLiftOptions.
DeclareGlobalFunction( "ComputeMinimalPolynomialEx@HMAC" );
@HMAC@PadicLift.ComputeMinimalPolynomialEx := ComputeMinimalPolynomialEx@HMAC;
DeclareGlobalFunction( "@HMAC@PadicLift.ComputeMinimalPolynomialEx" );


# given a finite field point of an ideal and an unknown list compute corresponding minimal polynomials for the unknowns over integers.
# Parameters:  ( solutionIdeal,  solutionPoint, unknowns,  liftOptions )
# minimalPolynomialVariable: usually same as unknown. See also CreateLiftOptions.
 DeclareGlobalFunction( "ComputeMinimalPolynomials@HMAC" );
@HMAC@PadicLift.ComputeMinimalPolynomials := ComputeMinimalPolynomials@HMAC;
DeclareGlobalFunction( "@HMAC@PadicLift.ComputeMinimalPolynomials" ); 

DeclareGlobalFunction( "LiftOptions@HMAC" );
@HMAC@PadicLift.LiftOptions := LiftOptions@HMAC;
DeclareGlobalFunction( "@HMAC@PadicLift.LiftOptions" );



########################## lift utils

DeclareProperty("IsLiftOptions", IsRecord );

# compute a compatibility matrix M where M[i][j]=k if ABS(combinedPolRoots[k] - operation( firstPolRoots[i], secondPolRoots[j] ) <  tolerance
# tolerance is adjusted depending on root values.
# Parameters: ( firstPolRoots, secondPolRoots, combinedPolRoots, operation, maxTolerance  )
DeclareGlobalFunction( "ComputeRootCompatibility@HMAC" );
@HMAC@PadicLift.ComputeRootCompatibility := ComputeRootCompatibility@HMAC;
DeclareGlobalFunction( "@HMAC@PadicLift.ComputeRootCompatibility" );

DeclareGlobalFunction( "DecimalToBitPrecision@HMAC" );
@HMAC@PadicLift.DecimalToBitPrecision := DecimalToBitPrecision@HMAC;


# create a wrapper object for Jenkins-Traub algorithm to compute polynomial roots
# Parameter: decimalPrecision 
DeclareGlobalFunction( "CreateJenkinsTraubWrapper@HMAC" );
@HMAC@PadicLift.CreateJenkinsTraubWrapper := CreateJenkinsTraubWrapper@HMAC;
DeclareGlobalFunction( "@HMAC@PadicLift.CreateJenkinsTraubWrapper" );


# compute roots using Jenkins Traub algorithm implementation
# Parameter: polynomial, decimalPrecision
DeclareGlobalFunction( "RootsByJenkinsTraub@HMAC" );
@HMAC@PadicLift.RootsByJenkinsTraub := RootsByJenkinsTraub@HMAC;
DeclareGlobalFunction( "@HMAC@PadicLift.RootsByJenkinsTraub" );


######################################################## PRIVATE #############################################################
@HMAC@PadicLift.Internal := rec();

DeclareGlobalFunction( "CREATE_LIFT_OPTIONS@HMAC");
@HMAC@PadicLift.Internal.CreateLiftOptions := CREATE_LIFT_OPTIONS@HMAC;

DeclareGlobalFunction( "CHECK_LIFT_OPTIONS@HMAC" );
@HMAC@PadicLift.Internal.CheckLiftOptions := CHECK_LIFT_OPTIONS@HMAC;

# compute  scalar product for matrix rows  ( (|.|_2)^2 ) (todo: how to compute a square root?)
DeclareGlobalFunction( "SquaredRowNorms@HMAC" );
@HMAC@PadicLift.Internal.SquaredRowNorms := SquaredRowNorms@HMAC;

# compute  scalar product  for matrix columns ( (|.|_2)^2 ) 
DeclareGlobalFunction( "SquaredColumnNorms@HMAC" );
@HMAC@PadicLift.Internal.SquaredColumnNorms := SquaredColumnNorms@HMAC;

# divide row norms by minimum value. Returns a 'NormalizedRowNorms' record.
DeclareGlobalFunction( "NormalizedSquaredRowNorms@HMAC" );
@HMAC@PadicLift.Internal.NormalizedSquaredRowNorms := NormalizedSquaredRowNorms@HMAC;


DeclareGlobalFunction( "CreateLiftInfo@HMAC" );
@HMAC@PadicLift.Internal.CreateLiftInfo := CreateLiftInfo@HMAC;


# Parameters: ( liftInfo1, liftInfo2 )
DeclareGlobalFunction( "MergeLiftInfo@HMAC" );
@HMAC@PadicLift.Internal.MergeLiftInfo := MergeLiftInfo@HMAC;


# Parameters: (unknown, indeterminates, liftResult, currentLatticeDim )
DeclareGlobalFunction( "LatticeBasisFromLift@HMAC" );
@HMAC@PadicLift.Internal.LatticeBasisFromLift := LatticeBasisFromLift@HMAC;

DeclareGlobalFunction( "IDEAL_POINTS_APPROXIMATION@HMAC" );
@HMAC@PadicLift.Internal.IdealPointsApproximation := IDEAL_POINTS_APPROXIMATION@HMAC;

#  rename '..RootCompatibility' to '..CoordinateCompatibility' ?

# adjust tolerance for coordinate pairing.
# Postcondition: returns adustedTolerance <= to the 1/3 of the minimal distance between two roots in rootList and adustedTolerance <= maxTolerance
# Parameters: ( maxTolerance, rootList)
DeclareGlobalFunction("AdjustRootPairingTolerance@HMAC");
@HMAC@PadicLift.Internal.AdjustPairingTolerance := AdjustRootPairingTolerance@HMAC;

# for a given lift try to find  the minimal polynomial in variable 'unknown' by guessing its degree (heurustic method)
# starting from an initial lattice dimension, increase it until either a solution candidate is found or stop condition is triggered.
# stop condition: either current lattice dimension > maxLatticeDimension or 
#               the minimun norm of all lattice vectors did not decrease/change in comparison to the previous one
# in case the stop conditon is triggered, proceed with next padic approximation instead.
# Parameters: (unknown, indeterminates, liftResult, nextLiftResult, reductionOpts ) 
#
# todo: something is fishy relating to the stop condition...
#
DeclareGlobalFunction( "LatticeBasisReductionStep@HMAC" );
@HMAC@PadicLift.Internal.LatticeBasisReductionStep := LatticeBasisReductionStep@HMAC;

# convert first lattice basis vector to a polynomial. 
DeclareGlobalFunction( "LatticeBasisToPolynomial@HMAC" );
@HMAC@PadicLift.Internal.LatticeBasisToPolynomial := LatticeBasisToPolynomial@HMAC;


# checks, if each row   contains at least one entry (exact=false)  or exact one entry (exact=true) 
# Parameters: (compatibiltyMatrix, exact)
DeclareGlobalFunction( "RootCompatibilityMatrixRowsValid@HMAC");
 @HMAC@PadicLift.Internal.CompatibilityRowsValid := RootCompatibilityMatrixRowsValid@HMAC;
 
 
# computes a basic compatibility matrix with property M[i][j]=1 if firstPolRoots[i] is compatible with secondPolRoots[j]. 
# Parameters: ( firstPolRoots, secondPolRoots, combinedPolRoots, operation, opts)
# Preconditions: Size(secondPolRoots)<= Size(firstPolRoots).
# Postconditions: returns compatibility matrix if rank of matrix is maximal and each row has exact one entry. Otherwise fails
# See also: ComputeRootCompatibility(...)
DeclareGlobalFunction( "ComputeWeakRootCompatibility@HMAC" );
@HMAC@PadicLift.Internal.ComputeHurwitzRootCompatibility := ComputeWeakRootCompatibility@HMAC;

# checks, if a compatibility matrix M is valid 
# (for each combined root there is a root compatibility and each row and column contains at least one entry ) 
#  M[i][j]=k if firstRootlist[i] , secondRootlist[j] and combinedRootList[k] are compatible.
# Parameters: (matrix, number of combined roots, logger )
# See also: ComputeRootCompatibility(...)
DeclareGlobalFunction( "IsValidRootCompatibility@HMAC");
@HMAC@PadicLift.Internal.IsValidRootCompatibility := IsValidRootCompatibility@HMAC;

# given a finite field point of an ideal compute corresponding approximate ideal points over complex numbers.
# Parameters:  ( ideal (over integers or rationals),  ideal point over finite field , lift options )
# see also 'ComputeApproxIdealPoint@HMAC' .
# limitations: may run faster than the generic version 'ComputeApproxIdealPoint' , but not succeed for all cases!
DeclareGlobalFunction( "ComputeApproxHurwitzIdealPoints@HMAC" );
@HMAC@PadicLift.Internal.ComputeApproxHurwitzIdealPoints := ComputeApproxHurwitzIdealPoints@HMAC;

#create a dummy logger function (logger interface: (loglevel, message) )
DeclareGlobalFunction( "CREATE_EMPTY_LOGGER_FKT@HMAC" );
@HMAC@PadicLift.Internal.CreateEmptyLoggerFkt := CREATE_EMPTY_LOGGER_FKT@HMAC;

DeclareGlobalFunction( "CREATE_FINITE_TEST_PROBLEM@HMAC" );
@HMAC@PadicLift.Internal.CreateFiniteTestProblem := CREATE_FINITE_TEST_PROBLEM@HMAC;


DeclareGlobalFunction( "CREATE_RATIONAL_TEST_PROBLEM@HMAC" );
@HMAC@PadicLift.Internal.CreateRationalTestProblem := CREATE_RATIONAL_TEST_PROBLEM@HMAC;

DeclareGlobalFunction( "CREATE_SYMM_TEST_PROBLEM@HMAC" );
@HMAC@PadicLift.Internal.CreateSymmTestProblem := CREATE_SYMM_TEST_PROBLEM@HMAC;



MakeImmutable(@HMAC@PadicLift.Internal);
MakeImmutable(@HMAC@PadicLift);


